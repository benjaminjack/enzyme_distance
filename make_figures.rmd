---
title: "Supplementary Text 3"
output:
  html_document:
    fig_caption: yes
  pdf_document: default
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}

rm(list=ls())
library(readr)
library(stringr)
library(tidyr)
library(dplyr)
library(cowplot)

knitr::opts_chunk$set(fig.width=12, fig.height=8,
                      echo=FALSE, warning=FALSE, message=FALSE, cache=FALSE)

options <- 'biological assemblies with interface residues removed'

```

The following figures were generated using `r options`.

```{r, echo=FALSE, warning=FALSE, message=FALSE}

# =============================================================
# ANALYSIS OPTIONS
# =============================================================

DATA_TABLE <- "master_data_table.csv" # Path to master data table
RAW_RATES <- T # Use raw rate4site rates rather than z-scores
MULTIMERS_ONLY <- F # Use only multimeric proteins
MONOMERS_ONLY <- F  # Use only monomeric proteins
MULTI_RSA <- T # Use multimeric RSA
MULTI_WCN <- T # Use multimeric WCN
NO_GLY <- F         # Remove glycines before analysis
NO_INTERFACE <- F   # Remove interface residues

# =============================================================
# END OPTIONS
# =============================================================

# Set some defaults for ggplot2
theme_set(
  theme_cowplot() + 
  theme(strip.background = element_rect(colour="black", 
                                        fill="grey80", 
                                        size=0.5, 
                                        linetype = "solid"))
)

# =============================================================
# DEFINE FUNCTIONS FOR ANALYSIS
# =============================================================

# Function to calculate correlations given a linear model or just two variables
calc_cor <- function(formula=NA, data) {
  if(is.na(formula)) {
    # No formula given, so calculate pearson correlation without linear model
    return(cor(data$y, data$x1))
  }
  m <- lm(formula, data=data)
  ypred <- predict(m, data)
  return(cor(data$y, ypred))
}

# Determine coefficient from a linear model
calc_coeff <- function(formula, data) {
  m <- lm(formula, data=data)
  return(coef(m)[2])
}

calc_pred <- function(formula, combo, data) {
  # Make model
  m <- lm(formula, data=data)
  # Pass predictions and residuals into dataframe
  ypred <- data.frame(predict(m, data), residuals(m))
  # Make column names
  title <- paste(combo, collapse=".")
  colnames(ypred) <- c(str_c(title, ".pred"), str_c(title, ".res"))
  # Bind new columns to data frame
  return(bind_cols(data,ypred))
}

make_lms <- function(df, y, vars) {
  # Initiate list to hold combinations of variables
  x <- c()
  # Create all combos of variables for linear models
  for (n in seq(length(vars))) { x <- append(x,combn(vars,n,simplify = F)) }
  # Loop over combos
  for (combo in x) {
    # Generate formula for linear model
    formula <- as.formula(paste(y,'~',paste(combo, collapse="+")))
    # Compute linear model predictions by protein
    df <- do(df, calc_pred(formula, combo, .))
  }
  return(df)
}

# Assign null model groups for facetting
get_null_group <- function(pred) {
  pred <- as.character(pred)
  pred[pred == 'wcnSC.pred'] <- 2
  pred[pred == 'wcnSC.dist_active.pred'] <- 2
  pred[pred == 'wcnSC.res'] <- 2
  pred[pred == 'wcnSC.dist_active.res'] <- 2
  pred[pred == 'RSA.pred'] <- 1
  pred[pred == 'RSA.dist_active.pred'] <- 1
  pred[pred == 'RSA.res'] <- 1
  pred[pred == 'RSA.dist_active.res'] <- 1
  pred[pred == 'rate'] <- 0
  pred[pred == 'dist_active.pred'] <- 0
  pred[pred == 'wcnSC.RSA.pred'] <- 3
  pred[pred == 'wcnSC.RSA.dist_active.pred'] <- 3
  pred[pred == 'wcnSC.RSA.res'] <- 3
  pred[pred == 'wcnSC.RSA.dist_active.res'] <- 3
  return(pred)
}

# Assign models as null or alternate
get_null <- function(pred) {
  pred <- as.character(pred)
  pred <- str_replace(pred, '.*dist_active.*', 'alt')
  pred[pred != 'alt'] <- 'null'
  return(pred)
}

# For labelling facets
label_size_group <- as_labeller(c(`1` = "Small Proteins",
                                  `2` = "Medium Proteins",
                                  `3` = "Large Proteins"))
label_null_group <- as_labeller(c(`1` = "RSA",
                                  `2` = "WCN",
                                  `3` = "WCN + RSA"))
label_rsa_group <- as_labeller(c(`1` = "Core",
                                 `2` = "Intermediate",
                                 `3` = "Surface"))

# =============================================================
# END FUNCTIONS
# =============================================================

# Read in master data table
master <- read_csv(DATA_TABLE, col_names=TRUE)

# Remove proteins without active site information
master.clean <- group_by(master[complete.cases(master),],pdb,Chain)

# Use raw rates ?
if (RAW_RATES == F) {
  master.clean <- mutate(master.clean, rate = z_rate)
}

# Interface residues ?
if (NO_INTERFACE == T) {
  master.clean <- filter(master.clean, abs(RSA - RSA_mono) < 0.001)
}

# Multimers only ?
if (MULTIMERS_ONLY == T) {
  master.clean <- filter(master.clean, multimer == 1)
}

# Monomers only ?
if (MONOMERS_ONLY == T) {
  master.clean <- filter(master.clean, multimer == 0)
}

# Multimeric WCN ?
if (MULTI_WCN == F) {
  master.clean <- mutate(master.clean, wcnSC = wcnSC_mono)
}

# Multimeric RSA ?
if (MULTI_RSA == F) {
  master.clean <- mutate(master.clean, RSA = RSA_mono)
}

# Glycines ?
if (NO_GLY == T) {
  master.clean <- filter(master.clean, Residue != 'G')
}

# =============================================================
# DATA PROCESSING
# =============================================================

# Define shell breaks
shell_breaks <- c(0, seq(2.5, max(master.clean$dist_active), by=5), max(master.clean$dist_active))

# Append predictions from linear models and their respective residuals
master.clean <- make_lms(master.clean, "rate", c("wcnSC", "RSA", "dist_active")) %>%
  mutate(length = n()) %>% # Add length of protein
  ungroup() %>%
  # Cut residues into shells as defined by shell_breaks above
  mutate(shell = cut(dist_active, labels=F, breaks = shell_breaks, include.lowest=T)) %>%
  mutate(shell = shell - 1) %>%
  group_by(pdb)

# Create quartiles for splitting data set based on protein size
quarts <- summarize(master.clean, length=unique(length)) %>% 
  mutate(ntile.size=ntile(length, 3)) %>%
  select(pdb, ntile.size)
# Append quartile data
master.clean <- inner_join(master.clean, quarts, by = c('pdb'='pdb'))

# Compute average RSA for active sites
master.act <- filter(master.clean, ACTIVE_SITE == 1) %>%
  summarize(active_site_rsa = mean(RSA)) %>%
  select(pdb, active_site_rsa)
# Define RSA breaks
# rsa_breaks <- quantile(master.act$active_site_rsa, probs=c(0, 0.333, 0.677, 1))
rsa_breaks <- c(0, 0.05, 0.25, 1)
master.act <- mutate(master.act,
                     rsa.group=cut(active_site_rsa, 
                                   breaks=rsa_breaks, 
                                   include.lowest = T, 
                                   labels=seq(1,3)))
master.clean <- inner_join(master.clean, select(master.act, pdb, rsa.group), by = c('pdb'='pdb'))

master.lmcor <- group_by(master.clean, pdb, multimer) %>% 
  summarise_each(funs(cor = cor.test(., rate)$estimate), ends_with(".pred"))

```

### Figure 1

```{r, echo=FALSE, warning=FALSE, message=FALSE, fig.height=12}

#########################################################
# FIGURE 1: DISTANCE AND RATE
#########################################################

# Basic distance vs rate plots
p1 <- ggplot(master.clean, aes(x=dist_active, y=rate)) + 
  ylab('Rate') + 
  xlab(expression(bold(paste('Distance to Catalytic Residue (', ring(A), ')')))) +
  geom_smooth(color="black") + 
  geom_vline(xintercept=32.5, size=1, color="red") + 
  coord_cartesian(xlim=c(0,80), ylim=c(0,3))
p2.label <- (sum(master.clean$dist_active < 32.5)/nrow(master.clean))*100
p2 <- ggplot(master.clean, aes(x=dist_active)) +
  geom_vline(xintercept=shell_breaks, linetype="dashed") +
  geom_density(fill="gray80") + 
  geom_vline(xintercept=32.5, color="red", size=1) +
  xlab(expression(bold(paste('Distance to Catalytic Residue (', ring(A), ')')))) +
  ylab('Density') + 
  annotate("text", label = paste0(sprintf("%.0f", p2.label), "%"), x = 18, y = 0.01, size = 7) +
  coord_cartesian(xlim=c(0,80))

pj3 <- ggplot(master.clean, aes(x=factor(shell), y=rate)) + 
  geom_violin(scale="width", trim=TRUE, aes(fill=..count..)) +
  stat_summary(fun.y=mean, geom="point") +
  stat_summary(fun.y=mean, geom="line", aes(group=1)) +
  geom_vline(xintercept=c(7.5), color="red", size=1) +
  coord_cartesian(ylim=c(0,3)) +
  xlab('Shell') +
  ylab('Rate') +
  scale_fill_gradient(name="Residue Count", low="lightblue", high="blue", trans="sqrt")

# Compile Figure 1 
p1.p2.pj3 <- ggdraw() +
  draw_plot(p1, x=0, y=0.5, width=0.5, height=0.5) +
  draw_plot(p2, x=0.5, y=0.5, width=0.5, height=0.5) +
  draw_plot(pj3, x=0, y=0, width=1, height=0.5) +
  draw_plot_label(c('a','b','c'), x = c(0, 0.5, 0), y= c(1,1,0.5))
p1.p2.pj3
```

Site-specific evolutionary rates increase with distance to a catalytic residue. Only data from `r options` are considered. (a) Site-specific evolutionary rate versus distance to the nearest catalytic residue. The curve represents the mean rate for all residues, smoothed with a generalized additive model. Standard error is shown in light gray. Individual residues are not shown. The vertical line indicates a distance of 32.5 \r{AA}. (b) Density plot of residues with a given distance to a catalytic residue. Dashed lines indicate the boundaries of shells with a thickness of 5 \r{AA} each. The vertical red line again shows a distance of 32.5, and the percentage shows the proportion of residues within this distnace. (c) Distribution of site-specific evolutionary rates within each shell. Violins show the distribution of rates in each shell, points represent the mean, and the shading represents the number of residues found in that shell. The red line indicates a distance of 32.5 \r{AA}, corresponding to the boundary of shell 6.

### Figure 2

```{r, echo=FALSE}
#########################################################
# FIGURE 2: RSA, WCN, AND DISTANCE
#########################################################

# Some preprocessing first...

# Gather predictions for plotting
master.preds <- select(master.clean, pdb, rate, shell, ends_with('.pred')) %>%
  gather(pred.type, pred, -pdb, -shell) %>%
  mutate(null.group = get_null_group(pred.type), null.model = get_null(pred.type))

# Get empirical rates
empirical <- filter(master.preds, pred.type=='rate') %>% select(-null.group) %>% mutate(null.model = "empirical")
# empirical <- master.preds[master.preds$pred.type=='rate',] %>% mutate(null.group = NULL, null.model = "empirical")

# Gather residuals
master.res <- select(master.clean, pdb, shell, rsa.group, ntile.size, ends_with('.res')) %>%
  gather(pred.type, pred, -ntile.size, -pdb, -shell, -rsa.group) %>%
  mutate(null.group = get_null_group(pred.type), null.model=get_null(pred.type))

# For supplemental...
pj5 <- ggplot(filter(master.preds, pred.type != 'rate'), 
              aes(x=factor(shell), y=pred, color=null.model, group=pred.type)) +
  stat_summary(fun.y=mean, geom="point") +
  stat_summary(fun.y=mean, geom="line") +
  xlim("0","1","2","3","4","5","6") +
  facet_grid(null.group ~ ., labeller=labeller(null.group = label_null_group)) +
  stat_summary(data=empirical, fun.y=mean, geom="point") +
  stat_summary(data=empirical, fun.y=mean, geom="line") +
  labs(color="Model", x="Shell", y="Rate") +
  scale_color_discrete(breaks=c("empirical", "null", "alt"), labels=c("Empirical Rate", "Structure", "Structure + d"))

target <- c('rate','dist_active.pred', 'wcnSC.RSA.dist_active.pred','wcnSC.RSA.pred')
pj20 <- ggplot(filter(master.preds, pred.type %in% target), 
              aes(x=factor(shell), y=pred, color=pred.type, group=pred.type)) +
  stat_summary(fun.y=mean, geom="point") +
  stat_summary(fun.y=mean, geom="line") +
  xlim(as.character(0:6)) +
  labs(color="Model", x="Shell", y="Rate") +
  scale_color_discrete(breaks=c("dist_active.pred", "wcnSC.RSA.pred", "wcnSC.RSA.dist_active.pred", "rate"), labels=c("d", "WCN + RSA", "WCN + RSA + d", "Empirical Rate")) +
  theme(legend.justification=c(1,0), legend.position=c(1,-0.05))
target <- c('dist_active.res', 'wcnSC.RSA.res', 'wcnSC.RSA.dist_active.res')
pj21 <- pj20 %+% filter(master.res, pred.type %in% target) +
  ylab('Residual') +
  scale_color_discrete(breaks=target, labels=c('d','WCN + RSA', 'WCN + RSA + d'))
pj21$layers <- c(geom_hline(yintercept=0, linetype="dashed"), pj21$layers)

# Square all of the correlations and make tidy
master.lmcor.tidy <- mutate_each(master.lmcor, funs(sq = (.)^2), ends_with('.pred')) %>%
  gather(input, cor, -pdb, -multimer)
p6.labels <- c('wcnSC.pred'=expression(K%~%WCN),
              'RSA.pred'=expression(K%~%RSA),
              'dist_active.pred'=expression(K%~%d),
              'wcnSC.RSA.pred'=expression(K%~%WCN+RSA),
              'wcnSC.dist_active.pred'=expression(K%~%WCN+d), 
              'RSA.dist_active.pred'=expression(K%~%RSA+d),
              'wcnSC.RSA.dist_active.pred'=expression(K%~%WCN+RSA+d))
p6 <- ggplot(master.lmcor.tidy, aes(x=factor(input, c('dist_active.pred',
                                                      'RSA.pred',
                                                      'wcnSC.pred',
                                                      'wcnSC.RSA.pred',
                                                      'wcnSC.dist_active.pred',
                                                      'RSA.dist_active.pred', 
                                                      'wcnSC.RSA.dist_active.pred')), y=cor))  +
  geom_violin(fill="grey80") + 
  scale_x_discrete(labels=p6.labels) +
  stat_summary(aes(group=input, y=cor, label=sprintf('%0.2f', ..y..)), fun.y=mean, geom="point") + 
  stat_summary(aes(group=input, y=cor, label=sprintf('%0.2f', ..y..)), fun.y=mean, geom="text", hjust=-0.3,vjust=0.5) +
  xlab('Model') + 
  ylab(expression(bold(R^"2"))) +
  coord_flip()

# Compile Figure 2
p6.pj20.pj21 <- ggdraw() +
  draw_plot(p6, 0, 0, 0.5, 1) +
  draw_plot(pj20, 0.5, 0.5, 0.5, 0.5) +
  draw_plot(pj21, 0.5, 0, 0.5, 0.5) +
  draw_plot_label(c('a','b','c'), c(0,0.5,0.5), c(1, 1, 0.5))

p6.pj20.pj21


```

Relative performance of functional and structural predictors of rate. Only data from `r options` are considered. (a) Distribution of $R^2$ values for various linear models explaining rate, fitted individually for each protein. Labeled points within each distribution indicate the mean $R^2$ value across proteins. Here, $K$ denotes the site-specific evolutionary rate, $d$ the distance to the nearest catalytic residue, WCN the weighted contact number, and RSA the relative solvent accessibility. On average, the addition of distance to the structural constraints WCN and RSA increases the percent variance explained by the linear models by at least 5 percentage points. (b) Mean empirical and predicted rates, separated by shell. A model containing only WCN and RSA overestimates rates near the active site of the enzyme and the addition of distance corrects this behavior. (c) Mean residuals for linear models with and without distance as a parameter, separated by shell.}

### Figure 3

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.height=12}

#########################################################
# FIGURE 5: Individual Examples
#########################################################

# Compute true pearson correlations, without using a linear model
master.cor <- summarize(master.clean, multimer=max(multimer), 
                      dist_wcn=calc_cor(data=data.frame(y=dist_active,x1=wcnSC)),
                      dist_rsa=calc_cor(data=data.frame(y=dist_active,x1=RSA)),
                      rsa_wcn=calc_cor(data=data.frame(y=RSA,x1=wcnSC)),
                      r4s_dist=calc_cor(data=data.frame(y=rate,x1=dist_active)), 
                      r4s_wcn=calc_cor(data=data.frame(y=rate,x1=wcnSC)), 
                      r4s_rsa=calc_cor(data=data.frame(y=rate,x1=RSA)),
                      r4s_wcnca=calc_cor(data=data.frame(y=rate,x1=wcnCA)))

# We must manually select proteins, otherwise it will be a different set depending on how we filter the data
# master.cor.ex <- mutate_each(master.cor, funs(abs), -pdb, -multimer) %>%
#  filter(r4s_dist > 0.5, dist_wcn < 0.25, dist_rsa < 0.25) 

master.cor.ex <- mutate_each(master.cor, funs(abs), -pdb, -multimer) %>% 
  filter(pdb == "1DHF" | pdb == "1DO6" | pdb == "1L0O" | pdb == "1SMN")
master.ex <- master.clean[master.clean$pdb %in% master.cor.ex$pdb,]
master.cor.ex <- master.cor.ex %>% 
  select(pdb, r4s_dist, r4s_wcn, r4s_rsa, dist_wcn, dist_rsa, rsa_wcn) %>%
  gather(pair, cor, -pdb)
p7 <- ggplot(master.cor.ex, aes(x=pair, y=cor, fill=pair)) + 
  geom_bar(stat="identity") +
  scale_x_discrete(labels=c('rsa_wcn' = 'RSA, WCN', 
                            'dist_rsa' = 'd, RSA', 
                            'dist_wcn' = 'd, WCN', 
                            'r4s_rsa' = 'K, RSA', 
                            'r4s_wcn' = 'K, WCN', 
                            'r4s_dist' = 'K, d')) +
  geom_text(aes(group=pair, y=cor, label=sprintf("%0.2f", cor)), hjust=-0.1) +
  xlab('Correlation') +
  ylab(expression(bold('|r|'))) +
  scale_y_continuous(breaks=c(0,0.25,0.5,0.75,1), lim=c(0, 1.1)) +
  facet_wrap(~ pdb, ncol = 1) +
  theme(legend.position = 'none', axis.title.x=element_text(vjust=0.2)) +
  coord_flip()
p8 <- ggplot(master.ex, aes(x=dist_active, y=gam_rate)) +
  geom_point() +
  xlab(expression(bold(paste('Distance to Catalytic Residue (', ring(A), ')')))) +
  ylab("Rate K") +
  facet_wrap(~ pdb, ncol=1)
p7.p8 <- plot_grid(p7, p8, ncol=2, align = 'h', rel_widths = c(1, 0.8), labels=c('a','b'))
p7.p8
```

Example enzymes from main text.  From top to bottom, the enzymes shown are 1DHF, 1DO6, 1L0O, and 1SMN. Only data from `r options` are considered. (a) Absolute Pearson correlations ($r$) between combinations of distance $d$, weighted contact number (WCN), relative solvent accessibility (RSA), and rate $K$. Distance correlates weakly with WCN or RSA, and strongly with rate, indicating that distance is a strong predictor independent of structural constraints RSA and WCN. (b) Rates smoothed with a GAM (generalized additive model) as a function of $d$, shown for every residue in each enzyme structure. Smoothed rates increase with distance throughout the entire enzyme structure.

### Figure 4

```{r, echo=FALSE}

#########################################################
# FIGURE 4: ACTIVE SITE RSA WITH RSA, WCN, AND DISTANCE
#########################################################

pj7 <- ggplot(master.act,
              aes(x=active_site_rsa)) +
  geom_density(fill="grey80") +
  geom_vline(xintercept = as.vector(rsa_breaks), linetype="dashed") +
  xlab('Active Site RSA') +
  ylab('Density')

dist.residuals <- filter(master.res, pred.type == 'dist_active.res') %>% 
  group_by(shell, ntile.size) %>%
  summarize(mean_pred = mean(pred), null.model=unique(null.model), pred.type = unique(pred.type)) %>%
  mutate(null.group = 1)

dist.residuals2 <- mutate(dist.residuals, null.group = 2)
dist.residuals3 <- mutate(dist.residuals, null.group = 3)

dist.residuals <- bind_rows(dist.residuals, dist.residuals2, dist.residuals3)

# Plot residuals vs size (for supplemental)
pj6 <- ggplot(filter(master.res, pred.type != 'dist_active.res'), 
              aes(x=factor(shell), y=pred, color=factor(null.model, labels=c('Structure + d', 'Structure')), group=pred.type)) +
  geom_hline(yintercept=0, linetype="dashed") +
  stat_summary(fun.y=mean, geom="point") +
  stat_summary(fun.y=mean, geom="line") +
  xlim("0","1","2","3","4","5","6") +
  facet_grid(null.group ~ ntile.size, labeller=labeller(null.group = label_null_group, ntile.size = label_size_group)) +
  geom_point(data=dist.residuals, aes(x=factor(shell), y=mean_pred, color=factor(null.model, labels=c('d')), group=pred.type)) +
  geom_line(data=dist.residuals, aes(x=factor(shell), y=mean_pred, color=factor(null.model, labels=c('d')), group=pred.type)) +
  xlab('Shell') +
  ylab('Residual') +
  scale_color_discrete(name="Model") +
  panel_border()

pj8 <- pj6 + facet_grid(null.group ~ rsa.group, labeller=labeller(null.group = label_null_group, rsa.group = label_rsa_group))
pj8
```

Effect of active-site location on the relationship between site-specific evolutionary rates and distance to the nearest catalytic residue. Only data from `r options` are considered. Enzymes are grouped into three categories, based on the mean solvent exposure of their catalytic residues: core (RSA $<$ 0.05), intermediate (0.05 $<$ RSA $<$ 0.25), and surface (RSA $>$ 0.25). Lines represent mean residuals for different structural linear models (vertical labels, right) and those same models with distance added as a parameter.

### Figure 5

```{r, echo=FALSE, warning=FALSE, message=FALSE}
#########################################################
# FIGURE 3: SIZE WITH RSA, WCN, AND DISTANCE
#########################################################

# Size vs distance
pj4 <- ggplot(master.clean, aes(x=factor(shell), y=rate)) +
  geom_violin(scale="width", trim=TRUE, aes(fill=..count..)) +
  stat_summary(fun.y=mean, geom="point") +
  stat_summary(fun.y=mean, geom="line", aes(group=1)) +
  coord_cartesian(ylim=c(0,3)) +
  xlab('Shell') +
  ylab('Rate') +
  xlim("0","1","2","3","4","5","6") +
  facet_grid( . ~ ntile.size, labeller = labeller(ntile.size = label_size_group)) +
  scale_fill_gradient(name="Residue Count", low="lightblue", high="blue", trans="sqrt") +
  panel_border()

target <- c('wcnSC.RSA.res', 'wcnSC.RSA.dist_active.res')
pj22 <- ggplot(filter(master.res, pred.type %in% target), 
              aes(x=factor(shell), y=pred, color=pred.type, group=pred.type)) +
  geom_hline(yintercept=0, linetype="dashed") +
  stat_summary(fun.y=mean, geom="point") +
  stat_summary(fun.y=mean, geom="line") +
  xlim("0","1","2","3","4","5","6") +
  facet_grid(. ~ ntile.size, labeller=labeller(ntile.size = label_size_group)) +
  xlab('Shell') +
  ylab('Residual') +
  scale_color_discrete(name="Model", labels=c('WCN + RSA', 'WCN + RSA + d')) +
  panel_border()

# Compile Figure 3
pj4.pj6 <- plot_grid(pj4, pj22, ncol = 1, align='v', labels=c('a','b'))

pj4.pj6

```

Effect of protein size on the relationship between site-specific evolutionary rates and distance to the nearest catalytic residue. Only data from `r options` are considered. (a) Distribution of rates within each shell, where proteins have been separated into small (95--326 sites), medium (327--484 sites), and large (485--1287 sites) based on amino-acid sequence length. Points represent the mean rate in each shell. As the size of the protein increases, the distance--rate slope decreases and distance effects extend further from the active site. (b) Mean residuals in each shell for models with and without distance, again separated by protein size. The constraining effects of catalytic residues depend on protein size, with stronger, more local effects in small proteins, and weaker, longer-range effects in large proteins.

<!-- ### Figure 6 -->
 
```{r, echo=FALSE, include=F}
#########################################################
# FIGURE 6
#########################################################

# master.act2 <- filter(master.clean, ACTIVE_SITE==1) %>%
#   summarize(ref_to_act = min(distance))
# p9 <- ggplot(master.act2, aes(x=ref_to_act)) + 
#   geom_histogram(color="black", fill="grey80", binwidth=1, aes(y=..count../sum(..count..)*100)) + 
#   xlab(expression(bold(paste("Distance to Catalytic Residue (", ring(A), ")")))) +
#   ylab("Enzymes (% of total)") +
#   scale_x_continuous(breaks=seq(0,65,10)) +
#   scale_y_continuous(expand=c(0,0), limits=c(0, 20)) +
#   annotate("rect", xmin = 0, xmax = 7, ymin = 0, ymax = 18, alpha = .25) +
#   annotate("errorbarh", xmin = 0, xmax = 7, y=18, x=0, color="red", size=1, height=1) +
#   annotate("text", label="51%", x=3.5, y=19, hjust=0.5, vjust=0)
# p9


master.act2 <- filter(master.clean, ACTIVE_SITE==1) %>%
  summarize(ref_to_act = min(distance.k123)) %>%
  mutate(group = (ref_to_act < 7.5))
p9 <- ggplot(master.act2, aes(x=ref_to_act, fill=group)) + 
  geom_histogram(color="black", binwidth=1.5, aes(y=..count../sum(..count..)*100)) +
  scale_fill_manual(values = c("grey80", "red")) +
  xlab(expression(bold(paste("Distance to Catalytic Residue (", ring(A), ")")))) +
  ylab("Enzymes (% of total)") +
  scale_x_continuous(breaks=seq(0,65,10)) +
  scale_y_continuous(expand=c(0,0), limits=c(0, 22)) +
  annotate("errorbarh", xmin = 0, xmax = 7.5, y=19, x=0, color="red", size=1, height=1) +
  annotate("text", label=paste0(round(sum(master.act2$ref_to_act<7.5)/nrow(master.act2)*100), "%"), x=3.75, y=20, hjust=0.5, vjust=0) +
  theme(legend.position = "none")
p9

master.act4 <- filter(master.clean, wcnSC == max(wcnSC)) %>%
  mutate(group = (dist_active < 7.5))
pj7 <- ggplot(master.act4, aes(x=dist_active, fill=group)) + 
  geom_histogram(color="black", binwidth=1.5, aes(y=..count../sum(..count..)*100)) + 
  scale_fill_manual(values = c("grey80", "red")) +
  xlab(expression(bold(paste("Distance to Catalytic Residue (", ring(A), ")")))) +
  ylab("Enzymes (% of total)") +
  scale_x_continuous(breaks=seq(0,65,10)) +
  scale_y_continuous(expand=c(0,0), limits=c(0, 20)) +
  annotate("errorbarh", xmin = 0, xmax = 7.5, y=15, x=0, color="red", size=1, height=1) +
  annotate("text", label=paste0(round(sum(master.act4$dist_active<7.5)/nrow(master.act4)*100), "%"), x=3.75, y=16, hjust=0.5, vjust=0) +
  theme(legend.position = "none")

library(ROCR)

glm.out <- glm(ACTIVE_SITE~distance.k123, master.clean, family=binomial)
pred <- prediction(predictions = glm.out$fitted.values, labels = master.clean$ACTIVE_SITE)
perf <- performance(pred,"tpr","fpr")
roc_df <- data.frame(fpr=perf@x.values[[1]], tpr=perf@y.values[[1]])
roc_plot <- ggplot(roc_df, aes(x=fpr, y=tpr)) + 
    geom_line() + 
    xlab("False Positive Rate") + 
    ylab("True Positive Rate")

```

<!-- The proportion of accurately predicted active sites above is significantly larger than the proportion predicted using maximum WCN:-->

```{r, echo=FALSE, include=F}
gt7.method2 <- sum(master.act2$ref_to_act >= 7.5)
lt7.method2 <- sum(master.act2$ref_to_act < 7.5)
gt7.method4 <- sum(master.act4$dist_active >= 7.5)
lt7.method4 <- sum(master.act4$dist_active < 7.5)
counts <- matrix(c(lt7.method2, gt7.method2, lt7.method4, gt7.method4), nrow = 2, dimnames = list(c("<7.5", ">7.5"), c("K ~ d + WCN + RSA", "Max WCN")))
counts
fisher.test(counts)
```

## Supporting Figures

### Figure S1

```{r, warning=FALSE, message=FALSE}
#########################################################
# FIGURE S1
#########################################################

p11 <- qplot(abs(master.cor$r4s_rsa), 
            abs(master.cor$r4s_wcn), 
            xlab="Correlation (K, RSA)", 
            ylab="Correlation (K, WCN)",
            xlim=c(0:1),
            ylim=c(0:1),
            alpha=0.5) + 
  geom_abline(intercept=0,slope=1) +
  coord_equal() +
  annotate("text", x=0.1, y=0.9, label=sum(abs(master.cor$r4s_wcn)>abs(master.cor$r4s_rsa)), fontface=2) +
  annotate("text", x=0.9, y=0.1, label=sum(abs(master.cor$r4s_wcn)<abs(master.cor$r4s_rsa)), fontface=2) +
  theme(legend.position="none")
p11
```

Pearson $r$ values of side-chain WCN and RSA correlated with site-specific evolutionary rates. Only data from `r options` are considered. The sign of the correlation coefficients for WCN are switched from negative to positive for a simpler comparison with RSA. Each point corresponds to an individual protein, and the numbers refer to the number of proteins above or below the $y = x$ line. In aggregate, WCN is a better predictor of site-specific evolutionary rate than RSA.

### Figure S2

```{r}
#########################################################
# FIGURE S2
#########################################################

# Tidy up correlation table
master.cor.tidy <- master.cor %>%
  select(pdb, multimer, dist_wcn, dist_rsa, rsa_wcn) %>%
  gather(lm, cor, -pdb, -multimer)
p5 <- ggplot(master.cor.tidy, aes(x=cor, fill=lm)) + 
  geom_density(alpha=0.25) + 
  labs(x="r", y="Density") + 
  scale_fill_manual(name="Combination", 
                    values=c("red","green","blue"), 
                    labels=c("d, WCN", "d, RSA", "WCN, RSA" )) +
  scale_x_continuous(breaks=seq(-1, 1, by=0.25), limits=c(-1,1)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p5

```

Distributions of Pearson $r$ correlations between pairs of site-specific evolutionary rate predictors on a per protein basis. Only data from `r options` are considered. Predictor pairs include distance and WCN, distance and RSA, and WCN and RSA. WCN and RSA correlate more strongly with each other than either does with distance.

### Figure S3

```{r}
#########################################################
# FIGURE S3
#########################################################

pj5

```

Empirical and predicted site-specific evolutionary rates from different combined linear models. Only data from `r options` are considered. "Structure" refers to one of three structural models used to predict rate: RSA, WCN, or RSA + WCN. "Structure + d" refers to these same three structural models, with the addition of distance to the nearest catalytic residue as a variable. Each point is the mean predicted rate for a given shell across all residues in the data set. In all cases, models that include distance as a parameter predict rate more accurately than models containing only structural parameters, especially near the active site. 

### Figure S4

```{r}
#########################################################
# FIGURE S4
#########################################################

pj6

```

Mean residuals for different combined linear models used to predict site-specific evolutionary rate. Only data from `r options` are considered. The data set is divided into small (95--326 sites), medium (327--484 sites), and large (485--1287 sites) proteins. Each point represents the mean predicted rate for all residues in a given shell.

<!-- ### Figure S5 -->

```{r, include=F}
#########################################################
# FIGURE S5
#########################################################

pj7
```

```{r, include=FALSE}
# Run the following code in order to save individual figures above as PDFs:
# save_plot("figures/roc_curve.pdf", roc_plot)
# save_plot('figS24.pdf', p1.p2.pj3, base_width = 10, base_height = 8)
# save_plot('figS25.pdf', p6.pj20.pj21, base_width = 12, base_height = 6)
# save_plot('figS26.pdf', pj4.pj6, ncol=1, base_width = 10, base_height = 6.5)
# save_plot('figS27.pdf', pj8, base_width=8, base_height = 6.5)
# save_plot('figS28.pdf', p7.p8, ncol=2, nrow=1, base_height = 10, base_width = 4)
# # save_plot('fig6.pdf', p9)
# save_plot('figS29.pdf', p11)
# save_plot('figS30.pdf', p5, base_width = 6, base_height = 4)
# save_plot('figS31.pdf', pj5, base_width = 6)
# save_plot('figS32.pdf', pj6, base_width = 8, base_height = 6.5)
# save_plot('figS5.pdf', pj7)
```
